#!/usr/bin/env python
# Adapted from the gl3w project to produce a C++ class rather than C bindings
# https://github.com/shakesoda/gl3w
# A Really elegant script!

import re
import os
import urllib2

# Download glcorearb.h
if not os.path.exists('glcorearb.h'):
    print 'Downloading glcorearb.h...'
    web = urllib2.urlopen('http://www.opengl.org/registry/api/glcorearb.h')
    with open('glcorearb.h', 'wb') as f:
        f.writelines(web.readlines())
else:
    print 'Reusing glcorearb.h...'

# Parse function names from glcorearb.h

#FFFFFFFUUUUUUUUUUUUUUUUUUUU
def convert_to_call(methodParams):
	print 'Method params: ' + methodParams
	output = []
	for item in methodParams[1:-1].split(','):
		item = item.strip()
		parts = item.split(' ')
		if parts.count > 1 and parts[0] != 'void':
			output.append(parts[-1].replace('*',''))
	print ','.join(output)
	return ','.join(output)

def parse_procedure(proc):
    return { 'p': proc[0],
             'p_s': proc[0][2:],
             'p_t': 'PFN' + proc[0].upper() + 'PROC',
             'p_m': proc[1][1:-1],
             'p_r': proc[2],
             'p_c': convert_to_call(proc[1][1:-1]),
             'macro': 'EC' if 'void' in proc[2] else 'EC_RET'	}

print 'Parsing glcorearb.h header...'
procs = []
p = re.compile(r'GLAPI(.*)APIENTRY\s+(\w+)(.*$)')
with open('glcorearb.h', 'r') as f:
    for line in f:
        m = p.match(line)
        if m:
            procs.append(parse_procedure([m.group(2),m.group(3),m.group(1)]))

# Generate gl3w.h
print 'Generating GL.h...'
with open('GL.h', 'wb') as f:
    f.write(r'''/** Auto generated by the gl3w_gen.py script **/
//glcoreab.h defines gl types and the gl header
#ifndef __gltypes_h_
#define __gltypes_h_
#endif

#ifndef __gl_h_
#define __gl_h_
#endif

#ifndef __gl3w_h_
#define __gl3w_h_

#include "glcorearb.h"

#ifndef __gl_h_
#define __gl_h_
#endif

struct Version 
{
	int major, minor;
};

class GL
{
public:
/* gl3w api */
	static int Init();
	static int IsSupported(int major, int minor);
	static void* GetProcAddress(const char *proc);
	static const Version& GetVersion();

/* OpenGL functions */
''')
    for proc in procs:
        f.write('	static%(p_r)s%(p_s)s%(p_m)s;\n' % proc)
    f.write('\n')
    f.write(r'''
};
#endif
''')

# Generate gl3w.c
print 'Generating GL.cpp in src...'
with open('GL.cpp', 'wb') as f:
    f.write(r'''/** Auto generated by the gl3w_gen.py script **/
#include "GL.h"

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>

static HMODULE libgl;

static void open_libgl(void)
{
	libgl = LoadLibraryA("opengl32.dll");
}

static void close_libgl(void)
{
	FreeLibrary(libgl);
}

static void *get_proc(const char *proc)
{
	void *res;

	res = wglGetProcAddress(proc);
	if (!res)
		res = GetProcAddress(libgl, proc);
	return res;
}
#elif defined(__APPLE__) || defined(__APPLE_CC__)
#include <Carbon/Carbon.h>

CFBundleRef bundle;
CFURLRef bundleURL;

static void open_libgl(void)
{
	bundleURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
		CFSTR("/System/Library/Frameworks/OpenGL.framework"),
		kCFURLPOSIXPathStyle, true);

	bundle = CFBundleCreate(kCFAllocatorDefault, bundleURL);
	assert(bundle != NULL);
}

static void close_libgl(void)
{
	CFRelease(bundle);
	CFRelease(bundleURL);
}

static void *get_proc(const char *proc)
{
	void *res;

	CFStringRef procname = CFStringCreateWithCString(kCFAllocatorDefault, proc,
		kCFStringEncodingASCII);
	res = CFBundleGetFunctionPointerForName(bundle, procname);
	CFRelease(procname);
	return res;
}
#else
#include <dlfcn.h>
#include <GL/glx.h>

static void *libgl;

static void open_libgl(void)
{
	libgl = dlopen("libGL.so.1", RTLD_LAZY | RTLD_GLOBAL);
}

static void close_libgl(void)
{
	dlclose(libgl);
}

static void *get_proc(const char *proc)
{
	void *res;

	res = glXGetProcAddress((const GLubyte *) proc);
	if (!res)
		res = dlsym(libgl, proc);
	return res;
}
#endif

Version version;

static int parse_version(void)
{
	if (!GL::GetIntegerv)
		return -1;

	GL::GetIntegerv(GL_MAJOR_VERSION, &version.major);
	GL::GetIntegerv(GL_MINOR_VERSION, &version.minor);

	if (version.major < 3)
		return -1;
	return 0;
}

static void load_procs(void);

int GL::Init(void)
{
	open_libgl();
	load_procs();
	close_libgl();
	return parse_version();
}

int GL::IsSupported(int major, int minor)
{
	if (major < 3)
		return 0;
	if (version.major == major)
		return version.minor >= minor;
	return version.major >= major;
}

const Version& GL::GetVersion()
{
	return version;
}

void *GL::GetProcAddress(const char *proc)
{
	return get_proc(proc);
}

''')
    for proc in procs:
        f.write('%(p_t)s m%(p_s)s;\n' % proc)
    f.write(r'''
static void load_procs(void)
{
''')
    for proc in procs:
        f.write('\tm%(p_s)s = (%(p_t)s) get_proc("%(p)s");\n' % proc)
    f.write(r'''
}

#define ERROR_CHECK
#ifdef ERROR_CHECK
#include <iostream>

void ErrorCheck()
{
    GLenum error = mGetError();
    if (error != GL_NO_ERROR)
    {
        const char* errorMessage;
        switch (error)
        {
            case GL_INVALID_ENUM:
                // An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.
                errorMessage = "GL_INVALID_ENUM";
                break;
               
            case GL_INVALID_VALUE:
                //A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.
                errorMessage = "GL_INVALID_VALUE";
                break;
                
            case GL_INVALID_OPERATION:
                //The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.
                errorMessage = "GL_INVALID_OPERATION";
                break;
                
            case GL_INVALID_FRAMEBUFFER_OPERATION:
                //The framebuffer object is not complete. The offending command is ignored and has no other side effect than to set the error flag.
                errorMessage = "GL_INVALID_FRAMEBUFFER_OPERATION";
                break;
                
            case GL_OUT_OF_MEMORY:
                //There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.
                errorMessage = "GL_OUT_OF_MEMORY";
                break;
                
            case GL_STACK_UNDERFLOW:
                //An attempt has been made to perform an operation that would cause an internal stack to underflow.
                errorMessage = "GL_STACK_UNDERFLOW";
                break;
                
            case GL_STACK_OVERFLOW:
                //An attempt has been made to perform an operation that would cause an internal stack to overflow.
                errorMessage = "GL_STACK_OVERFLOW";
                break;
        }
        
        std::cout << "OpenGL Error: " << errorMessage << std::endl;
        exit(1);
    }
}

#define EC(FUNCTION) { FUNCTION; ErrorCheck(); }
#define EC_RET(FUNCTION) { auto ret = FUNCTION; ErrorCheck(); return ret; }

#else

#define EC(FUNCTION) { FUNCTION; }
#define EC_RET(FUNCTION) { return FUNCTION; }
#endif

''')
    for proc in procs:
    	if proc['p_s'] != 'GetError':
	    	f.write('%(p_r)sGL::%(p_s)s%(p_m)s %(macro)s(m%(p_s)s(%(p_c)s))\n' % proc)
